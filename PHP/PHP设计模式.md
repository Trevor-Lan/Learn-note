**工厂模式**

> - 使用工厂方法或者类生成对象，而不是在代码中直接new



**单例模式**

> - 类对象仅允许创建一个
>
> - 构造方法声明为私有

```php
class Database
{

    private static $db;

    private function __construct()
    {

    }

    static function getInstance(): Database
    {
        if (!self::$db) {
            self::$db = new self();
        }
        return self::$db;
    }
}
```



**注册模式**

> - 全局共享和交换对象

```php
class Register
{
    protected static $object;

    static function set($alis, $obj)
    {
        self::$object[$alis] = $obj;
    }

    static function get($alis)
    {
        return self::$object[$alis];
    }

    static function unset($alis)
    {
        unset(self::$object[$alis]);
    }
}
```



**适配器模式**

> - 将不同的函数接口封装成统一的API，比如：
>
> 数据库适配器：mysql、mysqli、pdo
>
> 缓存适配器：file、redis、memcache



**策略模式**

> - 将一组特定的行为和算法封装成类，以适应某些特定的上下文环境，比如：
>
> - 比如首页根据不同用户类别来展示不同的广告。



**数据对象映射模式**

> - 将对象和数据存储映射起来，堆一个对象的操作会映射为堆数据存储的操作



**观察者模式**

> - 当对象状态发生变化时，依赖它的对象会收到通知，并自动更新，实现了低耦合，非侵入式的通知与更新机制。



**原型模式**

> - 与工厂模式作用类似，都是用来创建对象
>
> - 与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象，这样就免去类创建时的重复的初始化操作。
>
> - 原型模式适用于大对象的创建，创建一个大的对象需要很大的开销，如果每次new就会消耗很大，而原型模式仅需内存拷贝即可。



**装饰器模式**

> - 可以动态的修改类的功能。
>
> - 一个类提供了一项功能，如果在修改并添加额外的功能，传统的编码模式，需要写一个子类继承它，并重新实现类的方法。
>
> - 仅需在运行时添加一个装饰器对象即可实现，可以实现最大化的灵活性。



**迭代器模式**

> - 在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素。
>
> - 相比于传统的编码模式，迭代器模式可以隐藏遍历元素的所需的操作。



**代理模式**

> - 在客户端与实体之间建立一个代理对象，客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节。
> - 代理还可以与业务代码分离，部署到另外的服务器，业务代码中通过RPC来委派。

